---
title: "Translation Engine Specifications"
output:
 md_document: default
 html_document: default
 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
```

#### Features

The translation engine basically applies a set of translation rules, defined in a translation table, to create a new target table from a existing source table. 

- **Installation -** The translation engine is installed as a set of PostgreSQL functions defined in a .SQL file.

- **Execution -** The translation engine is executed as any normal SQL function. It returns a SETOF rows of type RECORD.

- **Configuration parameters -** The translation engine behavior can be configurated using a set of key/value parameters.

- **Translation table -** Rules for translating a source table into a target table are defined in a translation table. Each target table attribute is translated following a set of rules defined in one row of the translation table. Each row implements a set of validation rules, determining if the source values are acceptables, an invalidation rule, determining what to do when validation fails, and a translation rule, determining how to create the target attribute value from the source attribute values.

- **Rules documentation -** In addition to rules, a translation rule row allows textually describing (documenting) corresponding rules and flag them when they are not in synch with the description. This allows an editor to textually specify rules without actually implementing them but still be able to warn the rule writer that the spec changed.

- **Translation file validation -** Translation tables are validated before being processed. Target attributes should correspond to what is defined in the configuration file, helper functions should exist and no null value should be present.

- **Logging -** The translation engine produce a log table indicating invalidated values and progress of the translation process. The translation engine can be configured to stop or not as soon as it encounters an invalid value. 

- **Resuming -** The translation engine can be configured to resume from previous execution using the progress status logged in the log file.

#### Execution
- The translation engine is executed as any normal SQL function (TT_Translate(parameters...)).
- It can be used as part of any SELECT, FROM or WHERE SQL statement parts. e.g. CREATE TABLE AS SELECT (TT_Translate(parameters...)).*
- TT_Translate(parameters...) returns a SETOF rows of type RECORD. 
- Note: If it is not possible to return a SETOF RECORD, an initialisation function TT_Init() could create a empty table with the right types and TT_Translate() could rewrite itself into a temporary function with the right table as return type. TT_Translate() would then return the result of this temporary function...

- A typical execution sequence would look like:

    1) Write a very basic translation table.
    2) Translate.
    3) Translation stops as soon as a validation rule not providing an invalidation value fails or when its last parameter is specifically set to TRUE.
    4) Update the translation table and resume execution, back to 2).
    5) Translation file is complete, execution from scratch without stop on invalidation and all invalidation values provided.

#### Configuration parameters
- Translation engine configuration parameters are defined as a set of key/value.
- As far as the number of parameters is small, they can be passed as list of parameters to the main translation engine PostgreSQL function.
- As soon as the number of parameters becomes too big, they should be stored in a filesystem CSV table having two columns: "parameter"" and "value".. In that case the only parameter passed to the function would be the location of the configuration file.
- Current configuration parameters are listed in table 1 below.

**Table 1. Configuration parameters**
```{r echo = FALSE}
tab1 <- read.csv("./rmdTabs/engineSpecsTab1.csv")
kable(tab1)
```

#### Translation Tables
- A translation table is normal PostgreSQL table having a specific structure.
- Table 2 list the different attributes of a translation file.


**Table 2. Translation file attributes**
```{r echo = FALSE}
tab2 <- read.csv("./rmdTabs/engineSpecsTab2.csv")
kable(tab2)
```


#### Translation File Validation
- The translation engine must validate the structure and the content of the valisation file before starting any translation (or during the first translation?):

    - the list of target attributes names must match the names and the order defined in the targetAttributeList configuration variable. Each name should be shorter than 64 charaters and contain no spaces.
    - helper function names should match existing function and their parameters should be in the right format.
    - there should be no null or empty values in the tranlation file.



- The translation engine should stop if the translation file is invalidated in any way. This should not be configurable.
- Regular expression are used to check if helper function names are correct and contents of parentheses are valid. Parsing function will evaluate each helper function. Parser should also check if values outputted by the translationRules matches targetAttributeType.
- The translation engine should stop by default if descUpToDateWithRules is set to FALSE for any target attribute. This behavior is configurable.

#### Logging and Resuming
- The translation engine logs, in a logging table, the translation process and any invalid value.
- The translation engine normally stops as soon as it encounters an invalid value. It can resume its process, in a subsequent execution, starting at the row having triggered the invalid entry. This row is computed from the logging table as the first row trigerring the last PROGRESS entry + the count of processed rows for this entry.
- The logging table has the following columns:
    - logid - identifier of the log entry. A simple incrementing number.
    - timestamp - date and time of the log entry.
    - type - type of the logging entry (PROGRESS or INVALIDATION).
    - message - logging message itself mostly indicating reason of invalidation.
    - rownumber - number of the first row having triggered the log entry.
    - count - number of occurrence of the same invalidation since first trigered in the case of an INVALIDATION entry or the number or row processed in the case of a PROGRESS entry. That last number is used to determine the row from which to resume in a subsequent execution if this option is activated.

- All invalid values are reported even if invalidation rules are defined for those values.
- By default the translation engine stops when encountering an invalid value. It can also be set to not stop. In this case the tranlation process may generate thousands, even millions of similar log entries. To avoid this, entries of the same type are simply counted and reported with their count of occurence.
- The translation engine may be configured to continue even if an invalid value is encountered. This behavior is usefull to get a complete report of invalid values.
- Logging tables are used to resume translation after stop if configurated like this.
    - Log file should log progress of translation every 100 lines.

 

### Helper Functions Specifications

- There are three types of helper function:

    - **validation helper functions:** Boolean functions returning FALSE when passed attributes do not fulfill some specific conditions.

    - **invalidation helper functions:** Return a specific value when validation rules are NOT fulfilled. This can be an invalid code, a default value or an attempt to fix the invalid value.
    
    - **translation helper functions:** Return a specific value when validation rules are fulfilled.
    
- All validation and invalidation helper functions should be able to accept a single attribute or a comma separated list of attributes. E.g. smallerThan("first_name, last_name", 20) so that the function returns FALSE is any of the listed value does not fulfill the condition.
- When applicable, translate helper functions should be designed to be able to transform one or many attributes into one.
- Only the validation rules can be a semi-colon separated list of helper functions. Every function in the list must resolve to TRUE for the complete validation rule to be TRUE. This is the equivalent of putting a AND logical operator between each function.
- invalidation and translation rules, as they must return a single value, can not be composed of a list of functions. Both types of functions MUST return a value compatible with the type of the target attribute as defined by targetAttributeType.
- translation function should always double check for null values and if the passed values are of the right type.


#### List of validation rules functions

- **bool between(str variable, int lower_bnd, bool lb_inclusive=TRUE, int upper_bnd, bool ub_inclusive=TRUE)**
    - Returns a boolean: true if "variable" is >= "lower_bnd" and <= "upper_bnd"; else false
    - "lower_bnd" and "upper_bnd" are inclusive by default
    - Set "lb_inclusive" or "ub_inclusive" to FALSE to exclude corresponding bounds

- **bool greaterThan(str variable, float lower_bnd, bool lb_inclusive=TRUE)**
    - Returns a boolean: TRUE if "variable" is >= "lower_bnd"; else FALSE
    - "lower_bnd" is inclusive by default
    - Set "lb_inclusive" to FALSE to exclude corresponding bounds

- **bool lesserThan(str variable, float upper_bnd, bool ub_inclusive=TRUE)**
    - Returns a boolean: TRUE if "variable" is >= "upper_bnd"; else FALSE
    - "upper_bnd" is inclusive by default
    - Set "ub_inclusive" to FALSE to exclude corresponding bounds

#### List of invalid rules functions

- **Int invalid(str attribute_names, int null_value, int empty_value, int invalid_value)**
    - Returns "null_value" if one attribute listed in "attribute_names" is a true null, "empty_value" if one attribute listed in "attribute_names" is an empty string or "invalid_value" otherwise (if not null and not empty string).
     -e.g. invalid("-8888", "-1111", "-9999")

- **void stop()**
    - Stop the translation engine.
     
#### Notes

- CAS specific error codes extracted from Perl code:
    - INFTY => -1
    - ERRCODE => -9999 = Invalid values that are not null
    - SPECIES_ERRCODE => "XXXX ERRC"
    - MISSCODE => -1111 = Empty string ("") - does not apply to int and float
    - UNDEF=> -8888 = Undefined value - true null value - applies to all types
