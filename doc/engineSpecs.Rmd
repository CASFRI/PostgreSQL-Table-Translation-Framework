---
title: "Translation Engine Specifications"
output:
 html_document: default
 md_document: default


---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
```

#### Features

The translation engine basically applies a set of translation rules, defined in a translation table, to create a new target table from a existing source table. 

- **Installation -** The translation engine is installed as a set of PostgreSQL functions defined in a .SQL file.

- **Configuration parameters -** The translation engine behavior can be configurated using a set of key/value parameters.

- **Translation table -** Rules for translating a source table into a target table are defined in a translation table. Each target table attribute is translated following a set of rules defined in one dedicated row of the translation table. There is one row per target attribute. Each row implements a set of "validation rules", determining if the source values are valid and what to do otherwise, and a "translation rule", determining how to create the target attribute value from the source attribute values.

- **Rules documentation -** In addition to validation and translation rules, a translation row allows textually describing (documenting) corresponding rules and flag them when they are not in sync with the description. This allows an editor to textually specify rules without actually implementing them but still be able to warn the actual rule coder that the translation specification changed.

- **Execution -** The translation engine is executed as any normal SQL function. It returns a SETOF rows of type RECORD.

- **Translation file validation -** Translation tables are validated before being processed. Target attributes should match the attribute names and their order as defined in the configuration file. Helper functions should exist and no NULL value should be present in the translation table.

- **Logging -** The translation engine produce a log table indicating invalidated values and progress of the translation process. The translation engine can be configured to stop or not as soon as it encounters an invalid value. 

- **Resuming -** The translation engine can be configured to resume from the previous execution using the progress status logged in the log file.


#### Configuration parameters
- Translation engine configuration parameters are defined as a set of key/value.
- As long as the number of parameters stays small, they can be passed as list of parameters to the main translation engine function.
- As soon as the number of parameters becomes too big, they should be stored in a  table having two columns: "parameter" and "value". In that case the only parameter passed to the function would be the name of the configuration table.
- Current configuration parameters are listed in table 1 below.

**Table 1. Configuration parameters**
```{r echo = FALSE}
tab1 <- read.csv("./rmdTabs/engineSpecsTab1.csv")
kable(tab1)
```

#### Translation Tables
- A translation table is normal PostgreSQL table having a specific structure.
- Table 2 list the different attributes of a translation table.


**Table 2. Translation table attributes**
```{r echo = FALSE}
tab2 <- read.csv("./rmdTabs/engineSpecsTab2.csv")
kable(tab2)
```

#### Execution
- The translation engine is executed as any normal SQL function (TT_Translate(parameters...)).
- It can be used as part of any SELECT, FROM or WHERE SQL statement parts. e.g. CREATE TABLE AS SELECT (TT_Translate(parameters...)).*
- TT_Translate(parameters...) returns a SETOF rows of type RECORD. 

- Note: If it is not possible to return a SETOF RECORD, an initialisation function TT_Init() could create a empty table with the right types and TT_Translate() could rewrite itself into a temporary function with the temporary table as return type. TT_Translate() would then return the result of this temporary function...

- Another option would be to have the translation engine to return one row per call. The drawback is that the translation table would have to be read for each source row. i.e. maybe millions of time. One advantage of this option is that the TT_Translate() function would be more compatible with SQL syntax in that it would not refer to the source table as a parameter but in the FROm clause. TT_Translate() would only refer to its values.

- The execution stops if any of these condition is encountered:

    - The configuration variable "stopOnInvalid"" is set to TRUE and a source value is invalidated by a validation rule. This use case is helpful for validating and fixing source values when possible.
    - No invalidation value is defined for a validation rule and the source value is invalidated by this validation rule. This makes it mandatory to define an invalidation value. The translation process can not finish otherwise.
    - The configuration variable "stopOnInvalid"" is set to FALSE, all invalidation values are provided, one validation rule has its "stopOnInvalid" flag set and a source value is invalidated by this validation rule. This use case is helpful in a typical execution sequence as described below:


- Typical execution sequence:

    1) Write a basic translation table.
    2) Translate.
    3) Translation stops as soon as a validation rule not providing an invalidation value or having its "stopOnInvalid" parameter specifically set to TRUE fails.
    4) Update the translation table and resume execution; back to step 2).
    5) Translation file is complete. Translate from scratch with all invalidation values provided and "stopOnInvalid" set to FALSE in the configuraiton file and not set (default to FALSE) in any validation rule.

- These configuration options provide enough flexibility for many use cases.
- Multiple translations are managed though normal SQL coding.

#### Translation File Validation
- The translation engine must validate the structure and the content of the valisation file before starting any translation (or during the first translation?):

    - the list of target attributes names must match the names and the order defined in the "targetAttributeList" configuration variable. Each name should be shorter than 64 charaters and contain no spaces.
    - helper function names should match existing function and their parameters should be in the right format.
    - there should be no null or empty values in the translation file.



- The translation engine should stop if the translation table is invalidated in any way. This should not be configurable.
- Regular expression are used to check if helper function names and their parameters are valid. Parsing function will evaluate each helper function. Parser should also check if values outputted by the translation rule matches "targetAttributeType".
- The translation engine should stop by default if "descUpToDateWithRules"" is set to FALSE for any target attribute. This behavior is configurable.

#### Logging and Resuming
- The translation engine logs, in a logging table, the translation progress and any invalid value.
- The logging table has the same name as the source table with "_log" as suffix.

- The logging table has the following columns:
    - **logid -** identifier of the log entry. A simple incrementing number.
    - **timestamp -** date and time of the log entry.
    - **type -** type of the logging entry (PROGRESS or INVALIDATION).
    - **message -** logging message itself mostly indicating reason of invalidation.
    - **rowNumber -** number of the first row having triggered the log entry.
    - **count -** number of occurrence of the same invalidation since first trigered in the case of an INVALIDATION entry or the number or row processed in the case of a PROGRESS entry. That last number is used to determine the row from which to resume in a subsequent execution if this option is activated.

- If the translation engine is stopped by an invalidation condition, or because of a system failure, it can resume its process, in a subsequent execution, starting at the row having triggered the invalid entry or after the last row processed. In the first case this row is determined by the "rowNumber" logging table attribute. In the last case this row is computed from the first row triggering the last PROGRESS entry (equally stored as "rowNumber") + the "count" of processed rows for this entry.
- All invalid values are reported in the log even if invalidation rules are defined for those values and the engine is not set to stop on invalidation.
- If the translation engine is set to not stop when encountering an invalid value, it may generate thousands, even millions of similar log entries. To avoid this, entries of the same type are simply counted and their count is reported instead of reporting one row per invalidation.
- The translation engine may be configured to continue even if an invalid value is encountered. This behavior is usefull to get a complete report of invalid values.
- Progress is reported every "logFrequency" lines. This is a configuration variable defaulting to 500.

 

### Helper Functions Specifications

- There are two types of helper function:

    - **validation helper functions:** Return an invalidation code when passed values do not fulfill some specific conditions or a valid value.

    - **translation helper functions:** Return a specific value when validation rules are fulfilled.
    
- All validation helper functions should be able to accept a single attribute or a comma separated list of attributes. E.g. smallerThan("first_name, last_name", 20) so that the function returns FALSE is any of the listed value does not fulfill the condition.
- When applicable, translate helper functions should be designed to be able to transform one or many attributes into one.
- Only "validationRules" can be a semi-colon separated list of helper functions. This is the equivalent of putting a AND logical operator between each function.
- Every validation function must take a list of values, some parameters, an invalidation value and a flag indicating to stop the translation engine or not when one value is invalidated.
- Every validation function must return TRUE, FALSE or the invalidation value. 
- Translation rules must take a list of values and a set of parameters and return a single value of type compatible with the type of the target attribute as defined by "targetAttributeType".
- Translation functions should always double check for null values and if the passed values are of the right type.


#### List of validation rules functions

- **bool between(str variable, int lowerBound, bool lbInclusive=TRUE, int upperBound, bool ubInclusive=TRUE, str invalidValue=NULL, boolean stopEngine=FALSE)**
    - TRUE if "variable" >= "lowerBound" and "variable" <= "upperBound", FALSE or invalidValue otherwise.
    - "lbInclusive" and "ubInclusive" determines if corresponding bounds are inclusive or not.

- **bool greaterThan(str variable, float lowerBound, bool inclusive=TRUE, str invalidValue=NULL, boolean stopEngine=FALSE)**
    - TRUE if "variable" is >= "lowerBound", FALSE or invalidValue otherwise.
    - "inclusive" determines if "lowerBound" is inclusive.

- **bool lesserThan(str variable, float upperBound, bool inclusive=TRUE, str invalidValue=NULL, boolean stopEngine=FALSE)**
    - TRUE if "variable" is >= "upperBound", FALSE or invalidValue otherwise.
    - "inclusive" determines if "upperBound" is inclusive.

#### Notes

- CAS specific error codes extracted from Perl code:
    - INFTY => -1
    - ERRCODE => -9999 = Invalid values that are not null
    - SPECIES_ERRCODE => "XXXX ERRC"
    - MISSCODE => -1111 = Empty string ("") - does not apply to int and float
    - UNDEF=> -8888 = Undefined value - true null value - applies to all types
