Validation and translation function validation

One of the most difficult part is to check for the existence of a function before attempting to call it. A function with the right name might exist but be called with the wrong number of parameter or with the wrong parameter types. Here are some possible options to validate the validationRules and the translationRule.

A.  Validate only the function name. The list of available function could even be hardcoded so there would be no need to search in the PostgreSQL catalog for the existence of the function resulting in a faster check. A registration function would have to accompany any list of user custom functions to register them as available. This is easy, but as stated previously, functions might be called with the wrong number of parameters or with parameters of the wrong types leading to a failure when calling the function. This option is clearly not sufficient.

B.  Impose text only parameters for validation and translation helper functions. This is elegant since we would have only to check for the number of parameters, not for their types. This have the inconvenient that all parameters would have to be converted to text by the engine before calling the function and then to their natural type by the function itself before processing. However, this has the advantage of simplifying the number of variant we must implement for any particular helper function. As for the option where we would check for the function name only, the list of available function could be hardcoded with their respective number of parameters so there would be no need to search in the PostgreSQL catalog for the existence of the function. A registration function would have to accompany any list of user custom functions to register them as available. Many numbers would have to be provided for function with many variants.

C.  Check for both function names and parameter types. In this case we must properly determine if the function exists by correctly determining all the parameters types (the TT_GuessType() function already exist in the engine code) and check in the PostgreSQL catalog if the function exists (TT_FctExists()) with the right signature. The problem is that even if we determine a correct type for a parameter (e.g. integer) the function might be taking only a more generic type (e.g. float) and we will not find the proper signature in the catalog. We could search for all “more generic” signatures (e.g first check for “fctName(integer)”) and then for “fctName(float)” and then for “fctName(text)” but if the function has more than one parameter then we must search for every combination of signature involving the guessed type and the more generic types. This is not quite efficient and add a good level of complexity to the engine code.

D.  Test the function. We could also simply test for the existence of the function signature by trying to call it and catch the error with exceptions. If the call fails, we might simply consider that the function does not exist with this signature.

The performance cost for option C happens only once, at the beginning, when validating the table. The performance cost for option B happens for every translation. This might have a significant impact on the overall translation performance.
